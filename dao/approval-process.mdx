---
title: "Approval Process"
description: "How to approve or reject attack mode requests"
---

After reviewing an attack request, the DAO must decide to approve or reject. This guide covers the process and considerations for each outcome.

## Approving a Request

If the request passes review, approve it:

```solidity
// Approve the attack request
// This transitions the agreement from ATTACK_REQUESTED to UNDER_ATTACK
attackRegistry.approveAttack(agreementAddress);
```

### Effects of Approval

When you call `approveAttack()`:

1. Agreement state changes to `UNDER_ATTACK`
2. All contracts in scope become attackable
3. Safe Harbor protection begins
4. Event emitted: `AgreementStateChanged(agreementAddress, UNDER_ATTACK)`

### When to Approve

Approve when:

- Contracts are genuinely new (not mainnet copies)
- Agreement terms are reasonable
- Protocol appears legitimate
- No significant red flags identified

## Rejecting a Request

If the request fails review, reject it:

```solidity
// Reject the attack request
// This removes the agreement registration and clears contract mappings
attackRegistry.rejectAttackRequest(agreementAddress);
```

### Effects of Rejection

When you call `rejectAttackRequest()`:

1. Agreement state returns to `NOT_DEPLOYED`
2. Contract-to-agreement mappings are cleared
3. Protocol can submit a new request with corrections
4. Event emitted: `AgreementStateChanged(agreementAddress, NOT_DEPLOYED)`

### When to Reject

Reject when:

- Contracts are copies of mainnet protocols
- Agreement terms are unreasonable or potentially harmful
- Protocol cannot verify legitimacy
- Significant red flags identified
- Request appears to be testing the system

## Communicating Decisions

### After Approval

Consider notifying the protocol:
- Confirm their contracts are now in attack mode
- Remind them to monitor for attacks
- Provide any relevant guidance

### After Rejection

Provide clear feedback:
- Explain why the request was rejected
- Specify what needs to change for approval
- Offer guidance on resubmission if appropriate

## Handling Edge Cases

### Partial Concerns

If only some contracts raise concerns:

```solidity
// Option 1: Reject entirely
// Protocol can resubmit with problematic contracts removed
attackRegistry.rejectAttackRequest(agreementAddress);

// Option 2: Approve with conditions
// Document concerns, approve, and monitor closely
attackRegistry.approveAttack(agreementAddress);
// Note: There's no "conditional approval" on-chain
// This requires off-chain communication
```

### Time Pressure

If the 14-day auto-promotion deadline is approaching:

```solidity
// Check deadline
IAttackRegistry.AgreementInfo memory info = attackRegistry.getAgreementInfo(agreementAddress);
uint256 deadline = info.deadlineTimestamp;
uint256 timeLeft = deadline - block.timestamp;

// If time is short and review is incomplete:
// - Reject to reset the clock
// - Protocol can resubmit, giving more review time
```

### Disputed Requests

If there's disagreement among DAO members:

1. **Discuss**: Use governance forums to debate
2. **Vote**: If needed, hold a formal vote
3. **Document**: Record the decision rationale
4. **Act**: Execute the majority decision

## Timing Considerations

| Scenario | Recommended Action |
|----------|-------------------|
| Clear approval | Approve immediately |
| Clear rejection | Reject immediately with feedback |
| Needs more review | Decide before 14-day deadline |
| Approaching deadline, uncertain | Reject to reset clock |
| Emergency copycat discovered | Use `instantPromote()` |

## Batch Processing

For efficiency, the DAO can process multiple requests in a single transaction:

```solidity
// Approve multiple agreements
function batchApprove(address[] calldata agreements) external {
    for (uint i = 0; i < agreements.length; i++) {
        attackRegistry.approveAttack(agreements[i]);
    }
}

// Or a mix of approvals and rejections
function batchProcess(
    address[] calldata toApprove,
    address[] calldata toReject
) external {
    for (uint i = 0; i < toApprove.length; i++) {
        attackRegistry.approveAttack(toApprove[i]);
    }
    for (uint i = 0; i < toReject.length; i++) {
        attackRegistry.rejectAttackRequest(toReject[i]);
    }
}
```

## Events to Emit

The contract emits these events automatically:

```solidity
// On approval
event AgreementStateChanged(agreementAddress, ContractState.UNDER_ATTACK);

// On rejection
event AgreementStateChanged(agreementAddress, ContractState.NOT_DEPLOYED);
```

Monitor these events to track DAO actions and maintain transparency.

<Card title="Next: Instant Promotion" icon="arrow-right" href="/dao/instant-promotion">
  Learn about emergency promotion procedures
</Card>
