---
title: "Deploying to BattleChain"
description: "How to deploy contracts using BattleChainDeployer"
---

All contracts that want to use BattleChain's attack mode should be deployed via `BattleChainDeployer`. This contract extends [CreateX](https://github.com/pcaversaccio/createx) and automatically registers deployments with the `AttackRegistry`.

## Why Use BattleChainDeployer?

When you deploy via `BattleChainDeployer`:

1. Your contract is automatically registered with `AttackRegistry`
2. You (the deployer) are authorized to request attack mode
3. You can transfer authorization to an agreement owner if needed
4. The DAO can verify that contracts were legitimately deployed on BattleChain

## Deployment Methods

`BattleChainDeployer` supports all CreateX deployment methods:

### CREATE Deployments

```solidity
// Simple deployment
address newContract = battleChainDeployer.deployCreate(initCode);

// With initialization
address newContract = battleChainDeployer.deployCreateAndInit(
    initCode,
    initData,
    CreateX.Values({ constructorAmount: 0, initCallAmount: 0 }),
    refundAddress
);

// Clone deployment
address proxy = battleChainDeployer.deployCreateClone(implementation, initData);
```

### CREATE2 Deployments (Recommended)

CREATE2 gives you deterministic addresses, useful for cross-chain deployments:

```solidity
// With salt
address newContract = battleChainDeployer.deployCreate2(salt, initCode);

// Without explicit salt (uses msg.sender-based salt)
address newContract = battleChainDeployer.deployCreate2(initCode);

// With initialization
address newContract = battleChainDeployer.deployCreate2AndInit(
    salt,
    initCode,
    initData,
    CreateX.Values({ constructorAmount: 0, initCallAmount: 0 }),
    refundAddress
);

// Clone with CREATE2
address proxy = battleChainDeployer.deployCreate2Clone(salt, implementation, initData);
```

### CREATE3 Deployments

CREATE3 provides addresses independent of the init code:

```solidity
// With salt
address newContract = battleChainDeployer.deployCreate3(salt, initCode);

// With initialization
address newContract = battleChainDeployer.deployCreate3AndInit(
    salt,
    initCode,
    initData,
    CreateX.Values({ constructorAmount: 0, initCallAmount: 0 }),
    refundAddress
);
```

## Full Deployment Example

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import { BattleChainDeployer } from "src/BattleChainDeployer.sol";

contract MyProtocolDeployer {
    BattleChainDeployer public immutable deployer;

    constructor(address _deployer) {
        deployer = BattleChainDeployer(_deployer);
    }

    function deployMyProtocol(bytes32 salt) external returns (address vault, address strategy) {
        // Deploy vault
        bytes memory vaultBytecode = type(MyVault).creationCode;
        vault = deployer.deployCreate2(salt, vaultBytecode);

        // Deploy strategy with vault address
        bytes memory strategyBytecode = abi.encodePacked(
            type(MyStrategy).creationCode,
            abi.encode(vault)
        );
        bytes32 strategySalt = keccak256(abi.encodePacked(salt, "strategy"));
        strategy = deployer.deployCreate2(strategySalt, strategyBytecode);

        // Both contracts are now registered with AttackRegistry
        // msg.sender is authorized to request attack mode for both
    }
}
```

## Transferring Authorization

If your deployment script uses a different address than your protocol's multisig, you'll need to transfer authorization:

```solidity
// Deployer script deploys contracts
address myContract = battleChainDeployer.deployCreate2(salt, bytecode);

// Transfer authorization to the agreement owner (e.g., protocol multisig)
attackRegistry.authorizeAgreementOwner(myContract, protocolMultisig);

// Now protocolMultisig can request attack mode
```

## Verifying Deployment Registration

After deployment, verify your contracts are registered:

```solidity
// Check who deployed the contract
address deployer = attackRegistry.getContractDeployer(myContract);

// Check who is authorized to request attack mode
address authorized = attackRegistry.getAuthorizedOwner(myContract);
```

## What About External Deployments?

If you've already deployed contracts without using `BattleChainDeployer`, you can still request attack mode using `requestUnderAttackByNonAuthorized()`. However:

- The DAO will perform extra due diligence
- There's no cryptographic proof that you're the legitimate deployer
- Approval may take longer

<Warning>
We strongly recommend deploying via `BattleChainDeployer` for the smoothest experience.
</Warning>

<Card title="Next: Creating Agreements" icon="arrow-right" href="/protocols/agreements">
  Learn how to create a Safe Harbor agreement
</Card>
