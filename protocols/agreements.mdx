---
title: "Creating Safe Harbor Agreements"
description: "How to create and configure your Safe Harbor agreement"
---

A Safe Harbor agreement defines the terms under which whitehats can attack your contracts. It includes bounty terms, scope, contact details, and the asset recovery address.

## Agreement Structure

```solidity
struct AgreementDetails {
    string protocolName;           // Your protocol's name
    Contact[] contactDetails;      // Emergency contacts
    Chain[] chains;                // Scope by chain (including BattleChain)
    BountyTerms bountyTerms;       // Bounty configuration
    string agreementURI;           // Link to full legal agreement
}
```

## Creating an Agreement

Use `AgreementFactory` to create your agreement:

```solidity
// Prepare agreement details
AgreementDetails memory details = AgreementDetails({
    protocolName: "My Protocol",
    contactDetails: getContactDetails(),
    chains: getChainScope(),
    bountyTerms: getBountyTerms(),
    agreementURI: "ipfs://QmYourAgreementHash"
});

// Create the agreement
// The salt ensures deterministic addresses
bytes32 salt = keccak256("my-protocol-v1");
address agreementAddress = agreementFactory.create(details, owner, salt);
```

## Configuring Contact Details

Contact details allow whitehats to pre-notify you before public disclosure:

```solidity
function getContactDetails() internal pure returns (Contact[] memory) {
    Contact[] memory contacts = new Contact[](2);

    contacts[0] = Contact({
        name: "Security Lead",
        contact: "security@myprotocol.com"
    });

    contacts[1] = Contact({
        name: "Emergency Telegram",
        contact: "@myprotocol_security"
    });

    return contacts;
}
```

## Defining Chain Scope

The scope defines which contracts on which chains are covered:

```solidity
function getChainScope() internal pure returns (Chain[] memory) {
    Chain[] memory chains = new Chain[](1);

    // Define accounts (contracts) in scope
    Account[] memory accounts = new Account[](2);
    accounts[0] = Account({
        accountAddress: "0x1234567890123456789012345678901234567890",
        childContractScope: ChildContractScope.All  // Include child contracts
    });
    accounts[1] = Account({
        accountAddress: "0x0987654321098765432109876543210987654321",
        childContractScope: ChildContractScope.None
    });

    // BattleChain scope (required for attack mode)
    chains[0] = Chain({
        caip2ChainId: "eip155:325",  // BattleChain testnet
        assetRecoveryAddress: "0xYourRecoveryAddress",
        accounts: accounts
    });

    return chains;
}
```

### Child Contract Scope Options

| Value | Description |
|-------|-------------|
| `None` | Only the specified contract, no children |
| `ExistingOnly` | Contract + child contracts created before agreement |
| `All` | Contract + all child contracts (existing and future) |
| `FutureOnly` | Contract + only child contracts created after agreement |

## Configuring Bounty Terms

```solidity
function getBountyTerms() internal pure returns (BountyTerms memory) {
    return BountyTerms({
        bountyPercentage: 10,              // 10% of recovered funds
        bountyCapUsd: 5_000_000,           // Max $5M per whitehat
        retainable: true,                  // Whitehat keeps bounty from recovered funds
        identity: IdentityRequirements.Anonymous,  // No KYC required
        diligenceRequirements: "",         // Only for Named identity
        aggregateBountyCapUsd: 0           // No aggregate cap (0 = unlimited)
    });
}
```

### Bounty Configuration Options

<AccordionGroup>
  <Accordion title="Retainable vs Return-All">
    **Retainable (`true`)**: Whitehat keeps their bounty percentage from recovered funds and sends the rest to the recovery address.

    Example: Whitehat recovers $1M, keeps $100K (10%), sends $900K to recovery.

    **Return-All (`false`)**: Whitehat must send all recovered funds to the recovery address. Protocol pays bounty separately.

    Example: Whitehat recovers $1M, sends $1M to recovery, protocol pays $100K bounty separately.
  </Accordion>

  <Accordion title="Identity Requirements">
    - **Anonymous**: No identity verification required
    - **Pseudonymous**: Whitehat must provide a consistent pseudonym
    - **Named**: Whitehat must confirm their legal name (use `diligenceRequirements` to specify process)
  </Accordion>

  <Accordion title="Aggregate Bounty Cap">
    If set, caps total bounties across all whitehats for a single exploit.

    Example: `aggregateBountyCapUsd = 10_000_000` means total payouts won't exceed $10M even if multiple whitehats find the same issue.

    **Note**: Cannot use `aggregateBountyCapUsd` with `retainable = true`.
  </Accordion>
</AccordionGroup>

## Commitment Window

The agreement has a commitment window that prevents unfavorable changes to whitehats:

```solidity
// Extend the commitment window (can only extend, never shorten)
agreement.extendCommitmentWindow(block.timestamp + 30 days);
```

<Warning>
When requesting attack mode, the commitment window must be at least 7 days from the current time. This protects whitehats from terms being changed after they start work.
</Warning>

During the commitment window, you cannot:
- Reduce bounty percentage or caps
- Remove contracts from scope
- Make identity requirements stricter
- Change from retainable to return-all
- Modify the agreement URI

## Adopting the Agreement

After creating the agreement, adopt it in the registry:

```solidity
// This links your protocol address to the agreement
safeHarborRegistry.adoptSafeHarbor(agreementAddress);
```

## Modifying Agreements

Agreements are mutable, but some changes are restricted during the commitment window:

```solidity
// Always allowed
agreement.setProtocolName("New Protocol Name");
agreement.setContactDetails(newContacts);
agreement.addAccounts("eip155:325", newAccounts);

// Only favorable changes during commitment
agreement.setBountyTerms(betterTerms);  // Must be more favorable

// Blocked during commitment
agreement.removeChains(chainIds);       // Reverts
agreement.removeAccounts(chainId, addrs);  // Reverts
agreement.setAgreementURI(newUri);      // Reverts
```

<Card title="Next: Requesting Attack Mode" icon="arrow-right" href="/protocols/attack-mode">
  Learn how to request attack mode for your contracts
</Card>
