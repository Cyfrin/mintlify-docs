---
title: "Contract Reference"
description: "API reference for BattleChain core contracts"
---

This reference covers the core BattleChain contracts and their APIs.

## Deployed Addresses

<Note>
Contract addresses will be added after deployment. Check the official BattleChain documentation for the latest addresses.
</Note>

| Contract | Testnet | Mainnet |
|----------|---------|---------|
| AttackRegistry | TBD | TBD |
| BattleChainSafeHarborRegistry | TBD | TBD |
| AgreementFactory | TBD | TBD |
| BattleChainDeployer | TBD | TBD |

---

## AttackRegistry

Tracks the attack/production status of deployed contracts on BattleChain.

### Types

```solidity
enum ContractState {
    NOT_DEPLOYED,        // 0 - Not registered
    NEW_DEPLOYMENT,      // 1 - Deployed via BattleChainDeployer
    ATTACK_REQUESTED,    // 2 - Waiting for DAO approval
    UNDER_ATTACK,        // 3 - Open for attacks
    PROMOTION_REQUESTED, // 4 - Promotion pending (still attackable)
    PRODUCTION,          // 5 - Protected, no longer attackable
    CORRUPTED            // 6 - Successfully exploited
}

struct AgreementInfo {
    address attackModerator;           // Who can manage this agreement
    uint256 deadlineTimestamp;         // Auto-promotion deadline
    uint256 promotionRequestedTimestamp; // When promote() was called
    bool attackRequested;              // Attack mode requested?
    bool attackApproved;               // DAO approved?
    bool promoted;                     // In production?
    bool corrupted;                    // Was exploited?
    bool isRegistered;                 // Is registered with registry?
}
```

### Constants

```solidity
uint256 public constant PROMOTION_WINDOW = 14 days;
uint256 public constant PROMOTION_DELAY = 3 days;
uint256 public constant MIN_COMMITMENT = 7 days;
```

### Protocol Functions

<Accordion title="requestUnderAttack(address agreementAddress)">
Request attack mode for all contracts in an agreement's BattleChain scope.

**Requirements:**
- Caller must be the agreement owner
- All contracts must be deployed via BattleChainDeployer
- Agreement owner must be authorized for all contracts
- Commitment window must be at least 7 days

**Effects:**
- Sets agreement state to `ATTACK_REQUESTED`
- Links all scope contracts to the agreement
- Emits `AgreementStateChanged(agreementAddress, ATTACK_REQUESTED)`
</Accordion>

<Accordion title="requestUnderAttackByNonAuthorized(address agreementAddress)">
Request attack mode for externally deployed contracts.

**Use when:** Contracts weren't deployed via BattleChainDeployer.

**Note:** DAO will perform extra due diligence.
</Accordion>

<Accordion title="goToProduction(address agreementAddress)">
Skip attack mode and go directly to production.

**Requirements:**
- All contracts must be deployed via BattleChainDeployer
- Agreement owner must be authorized

**Effects:**
- Immediately sets state to `PRODUCTION`
- No attack phase, no Safe Harbor protection
</Accordion>

<Accordion title="promote(address agreementAddress)">
Request promotion to production (3-day delay).

**Requirements:**
- Caller must be the attack moderator
- Agreement must be in `UNDER_ATTACK` state

**Effects:**
- Sets state to `PROMOTION_REQUESTED`
- Starts 3-day countdown
- Contracts still attackable during delay
</Accordion>

<Accordion title="cancelPromotion(address agreementAddress)">
Cancel a pending promotion.

**Requirements:**
- Caller must be the attack moderator
- Agreement must be in `PROMOTION_REQUESTED` state

**Effects:**
- Returns to `UNDER_ATTACK` state
- Resets promotion timestamp
</Accordion>

<Accordion title="markCorrupted(address agreementAddress)">
Mark an agreement as corrupted after successful attack.

**Requirements:**
- Caller must be the attack moderator
- Agreement must be in `UNDER_ATTACK` or `PROMOTION_REQUESTED`

**Effects:**
- Sets state to `CORRUPTED` (terminal)
</Accordion>

<Accordion title="authorizeAgreementOwner(address contractAddress, address newOwner)">
Authorize an address to request attack mode for a contract.

**Requirements:**
- Caller must be the current authorized owner
- Contract must have been deployed via BattleChainDeployer
</Accordion>

<Accordion title="transferAttackModerator(address agreementAddress, address newModerator)">
Transfer attack moderator role.

**Requirements:**
- Caller must be the current attack moderator
</Accordion>

### DAO Functions

<Accordion title="approveAttack(address agreementAddress)">
Approve an attack request.

**Requirements:**
- Caller must be the registry moderator
- Agreement must be in `ATTACK_REQUESTED` state

**Effects:**
- Sets state to `UNDER_ATTACK`
- Safe Harbor protection begins
</Accordion>

<Accordion title="rejectAttackRequest(address agreementAddress)">
Reject an attack request.

**Requirements:**
- Caller must be the registry moderator
- Agreement must be in `ATTACK_REQUESTED` state

**Effects:**
- Returns state to `NOT_DEPLOYED`
- Clears contract-to-agreement mappings
</Accordion>

<Accordion title="instantPromote(address agreementAddress)">
Instantly promote to production (emergency).

**Requirements:**
- Caller must be the registry moderator
- Agreement must be in `ATTACK_REQUESTED`, `UNDER_ATTACK`, or `PROMOTION_REQUESTED`

**Effects:**
- Immediately sets state to `PRODUCTION`
- Safe Harbor protection ends
</Accordion>

### View Functions

```solidity
// Check if a contract is attackable
function isTopLevelContractUnderAttack(address contractAddress) external view returns (bool);

// Get agreement state
function getAgreementState(address agreementAddress) external view returns (ContractState);

// Get full agreement info
function getAgreementInfo(address agreementAddress) external view returns (AgreementInfo memory);

// Get agreement for a contract
function getAgreementForContract(address contractAddress) external view returns (address);

// Get attack moderator
function getAttackModerator(address agreementAddress) external view returns (address);

// Get contract deployer
function getContractDeployer(address contractAddress) external view returns (address);

// Get authorized owner
function getAuthorizedOwner(address contractAddress) external view returns (address);

// Get registry moderator
function getRegistryModerator() external view returns (address);
```

### Events

```solidity
event AgreementStateChanged(address indexed agreementAddress, ContractState newState);
event AttackModeratorTransferred(address indexed agreementAddress, address indexed newModerator);
event ContractRegistered(address indexed contractAddress, address indexed agreementAddress);
event AgreementOwnerAuthorized(address indexed contractAddress, address indexed authorizedOwner);
```

---

## Agreement

Per-protocol contract containing bounty terms, contact details, and scope.

### Types

```solidity
struct AgreementDetails {
    string protocolName;
    Contact[] contactDetails;
    Chain[] chains;
    BountyTerms bountyTerms;
    string agreementURI;
}

struct Contact {
    string name;
    string contact;
}

struct Chain {
    string assetRecoveryAddress;
    Account[] accounts;
    string caip2ChainId;
}

struct Account {
    string accountAddress;
    ChildContractScope childContractScope;
}

enum ChildContractScope {
    None,          // No children included
    ExistingOnly,  // Only pre-existing children
    All,           // All children (existing + future)
    FutureOnly     // Only future children
}

struct BountyTerms {
    uint256 bountyPercentage;      // 0-100
    uint256 bountyCapUsd;          // Max bounty per whitehat
    bool retainable;               // Can keep from recovered funds?
    IdentityRequirements identity; // KYC level
    string diligenceRequirements;  // For Named identity
    uint256 aggregateBountyCapUsd; // Total cap across all whitehats
}

enum IdentityRequirements {
    Anonymous,
    Pseudonymous,
    Named
}
```

### Owner Functions

```solidity
function setProtocolName(string calldata protocolName) external onlyOwner;
function setContactDetails(Contact[] memory contactDetails) external onlyOwner;
function addOrSetChains(Chain[] memory chains) external onlyOwner;
function removeChains(string[] memory caip2ChainIds) external onlyOwner;
function addAccounts(string memory caip2ChainId, Account[] memory newAccounts) external onlyOwner;
function removeAccounts(string memory caip2ChainId, string[] memory accountAddresses) external onlyOwner;
function setBountyTerms(BountyTerms memory bountyTerms) external onlyOwner;
function setAgreementURI(string calldata agreementURI) external onlyOwner;
function extendCommitmentWindow(uint256 newCantChangeUntil) external onlyOwner;
```

### View Functions

```solidity
function getDetails() external view returns (AgreementDetails memory);
function getProtocolName() external view returns (string memory);
function getBountyTerms() external view returns (BountyTerms memory);
function getAgreementURI() external view returns (string memory);
function getChainIds() external view returns (string[] memory);
function getChainAccounts(string memory caip2ChainId) external view returns (Account[] memory);
function getAssetRecoveryAddress(string memory caip2ChainId) external view returns (string memory);
function getCantChangeUntil() external view returns (uint256);
function getBattleChainScopeAddresses() external view returns (address[] memory);
function isContractInScope(address contractAddress) external view returns (bool);
```

---

## AgreementFactory

Factory for creating Agreement contracts.

### Functions

```solidity
// Create a new agreement
function create(
    AgreementDetails memory details,
    address owner,
    bytes32 salt
) external returns (address agreementAddress);

// Check if address is a valid agreement
function isAgreementContract(address agreementAddress) external view returns (bool);

// Get the registry address
function getRegistry() external view returns (address);

// Get BattleChain CAIP-2 chain ID
function getBattleChainCaip2ChainId() external view returns (string memory);
```

### Events

```solidity
event AgreementCreated(address indexed agreementAddress, address indexed owner, bytes32 indexed salt);
```

---

## BattleChainSafeHarborRegistry

Maps protocol addresses to their Agreement contracts.

### Functions

```solidity
// Adopt a Safe Harbor agreement
function adoptSafeHarbor(address agreementAddress) external;

// Get agreement for an adopter
function getAgreement(address adopter) external view returns (address);

// Check if chain is valid
function isChainValid(string calldata caip2ChainId) external view returns (bool);

// Check if agreement is valid (from factory)
function isAgreementValid(address agreementAddress) external view returns (bool);
```

### Owner Functions

```solidity
function setValidChains(string[] calldata caip2ChainIds) external onlyOwner;
function setInvalidChains(string[] calldata caip2ChainIds) external onlyOwner;
function setAgreementFactory(address factory) external onlyOwner;
```

### Events

```solidity
event BattleChainSafeHarborAdoption(address indexed entity, address newDetails);
event ChainValiditySet(string caip2ChainId, bool valid);
event AgreementFactorySet(address indexed factory);
```

---

## BattleChainDeployer

Extends CreateX to automatically register deployments.

### Supported Deployment Methods

All CreateX methods are supported with automatic registration:

```solidity
// CREATE
function deployCreate(bytes memory initCode) public payable returns (address);
function deployCreateAndInit(...) public payable returns (address);
function deployCreateClone(address implementation, bytes memory data) public payable returns (address);

// CREATE2
function deployCreate2(bytes32 salt, bytes memory initCode) public payable returns (address);
function deployCreate2(bytes memory initCode) public payable returns (address);
function deployCreate2AndInit(...) public payable returns (address);
function deployCreate2Clone(...) public payable returns (address);

// CREATE3
function deployCreate3(bytes32 salt, bytes memory initCode) public payable returns (address);
function deployCreate3(bytes memory initCode) public payable returns (address);
function deployCreate3AndInit(...) public payable returns (address);
```

All deployments automatically call `AttackRegistry.registerDeployment()` to record the deployment.
