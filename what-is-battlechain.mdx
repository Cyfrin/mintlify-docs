---
title: "What is BattleChain?"
description: "A pre-mainnet, post-testnet environment for stress testing smart contracts"
---

## The Gap in Web3 Security

Traditional software development has well-established staging environments where code is tested with production-like conditions before release. Web3 lacks this critical phase:

| Traditional Software | Web3 Today | With BattleChain |
|---------------------|------------|------------------|
| Development → Staging → Production | Development → Testnet → Mainnet | Development → Testnet → **BattleChain** → Mainnet |
| Staging has real-like data | Testnet has fake money | BattleChain has real funds |
| Issues found before users affected | Issues found after millions at risk | Issues found with controlled risk |

## What Makes BattleChain Different

### Real Incentives

Unlike testnets where there's no financial incentive to find bugs, BattleChain uses real funds. This attracts serious security researchers and creates genuine stress testing conditions.

### Legal Protection

All contracts in "attack mode" are covered by a Safe Harbor agreement. Whitehats can attack these contracts without legal risk, as long as they follow the bounty terms (return funds minus their bounty to the recovery address).

### Isolated Environment

BattleChain is a dedicated L2 chain. This isolation:
- Prevents contagion with mainnet liquidity
- Provides clear branding as an experimental environment
- Enables contract-level state tracking at the protocol level

## Contract Modes

Every contract on BattleChain exists in one of two modes:

<CardGroup cols={2}>
  <Card title="Attack Mode" icon="crosshairs">
    **Open season for ethical hacking**

    - Whitehats can legally exploit vulnerabilities
    - Safe Harbor agreement protects attackers
    - Bounties paid for successful exploits
  </Card>
  <Card title="Production Mode" icon="shield-check">
    **Protected like mainnet**

    - No legal protection for attacks
    - Same security expectations as mainnet
    - Regular bug bounty rules apply
  </Card>
</CardGroup>

## The Flow

<Steps>
  <Step title="Deploy">
    Protocol deploys audited contracts to BattleChain via `BattleChainDeployer`, which automatically registers them for potential attack mode.
  </Step>
  <Step title="Configure">
    Protocol creates a Safe Harbor agreement defining:
    - Bounty percentage and caps
    - Asset recovery address
    - Contracts in scope
    - Identity requirements for whitehats
  </Step>
  <Step title="Request">
    Protocol calls `requestUnderAttack()` to request attack mode. The DAO reviews to ensure the contract isn't a mainnet copycat.
  </Step>
  <Step title="Battle">
    Once approved, whitehats attack the contracts. Any recovered funds go to the asset recovery address, minus the whitehat's bounty.
  </Step>
  <Step title="Promote">
    After sufficient stress testing, the protocol calls `promote()`. After a 3-day delay, contracts enter production mode.
  </Step>
</Steps>

## Why an L2?

BattleChain runs as a ZKSync-based L2 for several reasons:

1. **Isolation**: Attacks on BattleChain don't affect mainnet liquidity
2. **Branding**: Clear distinction that this is an experimental environment
3. **Protocol-level tracking**: Contract states are tracked at the chain level
4. **Efficiency**: Lower costs for deployment and testing

## Who Should Use BattleChain?

**Every protocol should have a BattleChain instance.** Whether you're:

- Launching a new protocol
- Adding new features to an existing protocol
- Testing experimental DeFi mechanisms
- Stress testing AI trading bots

BattleChain provides the safe environment you need to validate your code with real economic incentives before risking mainnet funds.
